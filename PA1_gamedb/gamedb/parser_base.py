import attr
import inspect
import pyparsing as pp
from pyparsing import Optional, ParseBaseException, ParserElement
import string
from typing import Callable, Dict

# A constant that matches any whitespace but doesn't include it in the result
WS_TOK = pp.White().setName("<space>").suppress()
# A token to match a word, used for built-in help.
CMD_TOK = pp.Word(string.ascii_letters + string.digits)


def pretty_print_parser_error(exc: ParseBaseException):
    """
    Returns a multiline string showing the location that parsing failed
    and the comment from the exception.
    """
    if not isinstance(exc, ParseBaseException):
        raise ValueError("Only pyparsing exceptions may be passed.")

    string, location = exc.args[:2]
    description = exc.msg
    lines = string.split("\n")

    # Put description on the left or right of the arrow depending on its length
    if len(description) < (exc.col - 1):
        errline = (description + " ^").rjust(exc.col)
    else:
        errline = "^ ".rjust(exc.col + 1) + description

    # Insert the line with the arrow + description and return the joined block
    lines.insert(exc.lineno + 1, errline)
    return "\n".join(lines)


@attr.s(auto_attribs=True)
class ParserCommand:
    """
    A class containing information about a command's arguments and callback

    Constructor is autogenerated by attrs, but takes the attributes as args.

    Attributes
    ----------
    name : str
        The name of the command as it is to be called.
    params : Dict[str, ParserElement]
        A mapping between parameters' name and ParserElement.

        Python 3.6+ preserves the order of dict entries.
    func: Callable
        The command function. Called with parsed arguments as kwargs.
    """

    name: str
    params: Dict[str, ParserElement]
    func: Callable

    @property
    def short_help(self) -> str:
        "A shortcut to return the first line of the callback's docstring"
        docstring_lines = inspect.getdoc(self.func).split("\n")

        if docstring_lines:
            return docstring_lines[0]
        else:
            return "(no help defined)"

    @property
    def help(self) -> str:
        "A shortcut to return the callback's docstring"
        return inspect.getdoc(self.func)

    def build_element(self):
        """
        Builds an element containing the full command and arguments

        Elements are joined with the `-` operator, which stops parsing
        immediately if the element fails to match. Elements are joined
        with a token that matches one or more whitespace characters.
        """
        if isinstance(self.name, ParserElement):
            command_element = self.name
        else:
            command_element = pp.Keyword(self.name)

        # SetResultsName creates a copy instead of mutating the element
        command_element = command_element.setResultsName("command_name")

        for arg_name, arg_element in self.params.items():
            if hasattr(arg_element, "name"):
                display_name = f"{arg_name} ({arg_element.name})"
            else:
                display_name = arg_name

            element = WS_TOK - arg_element.setResultsName(arg_name).setName(display_name)

            # If element is optional, make WS + element optional
            if isinstance(arg_element, pp.Optional):
                element = Optional(element)

            command_element -= element

        return command_element


# underscore on _name in case a parameter called name is passed
def decorate_command(_name, **param_elements):
    "Decorates a command function to turn it into a ParserCommand"

    def _decorate(func):
        return ParserCommand(name=_name, func=func, params=param_elements)

    return _decorate


class CommandParser:
    """
    A base class for command parsing.

    Parameters
    ----------
    parent : Optional[Any]
        Any object that should be assigned to the parent attribute.
        Used to allow commands to easily access external state.

    Attributes
    ----------
    parent : Optional[Any]
        The parent passed to the constructor. Used to access controlling code
        from inside command functions.
    commands : Dict[str, ParserCommand]
        A mapping between command names and objects.
    top_level_element : ParserElement
        The ParserElement that will attempt to match any registered command.
    """

    def __init__(self, parent=None):
        self.parent = parent
        self.commands = self.gather_commands()
        self.top_level_element = self.build_element()

    @classmethod
    def gather_commands(cls):
        """
        Returns a dict of any ParserCommands bound to the class keyed by name.
        """
        commands = {}

        # Populate commands from base class first
        if issubclass(cls.__base__, CommandParser):
            commands.update(cls.__base__.gather_commands())

        # Tracks duplicate commands in the same inheritance level
        current_class_commands = set()

        for name, obj in vars(cls).items():
            if isinstance(obj, ParserCommand):
                if obj.name in current_class_commands:
                    raise ValueError(f"Duplicate command registration: {obj.name}")

                current_class_commands.add(obj.name)
                commands[obj.name] = obj

        return commands

    def build_element(self):
        """
        A helper function to assemble the command parser's top level element.
        """
        command_elements = []

        for command in self.commands.values():
            command_elements.append(command.build_element())

        # Enforce command at string start
        element = pp.StringStart()

        # Attempt to match command name only first using lookahead
        commands_element = pp.MatchFirst(pp.Keyword(c) for c in self.commands)
        element -= pp.FollowedBy(commands_element)

        # If the above lookahead element matches, the parser will then look for
        # one of the full command string. Otherwise, it will stop immediately.
        element -= pp.MatchFirst(command_elements).setParseAction(self.on_match)

        # Enforce no extra arguments.
        element -= pp.StringEnd()

        return element

    def on_match(self, parse_result):
        """
        Called by the parser when a full command string is matched.
        """
        command = self.commands[parse_result["command_name"]]

        args = {k: parse_result[k] for k in command.params if k in parse_result}
        return command.func(self, **args)

    def parse(self, command: str):
        """
        A shortcut to invoke the top-level element parser.
        """
        return self.top_level_element.parseString(command, parseAll=False)

    @decorate_command("help", command=Optional(CMD_TOK))
    def cmd_help(self, command: str = None):
        """
        A built-in command to display a command help or list.

        Usage: help [command]
        """
        if command is None:
            command_list = sorted(self.commands.items())
            print("Available commands:")
            print("\n".join(f"{name} - {cmd.short_help}" for name, cmd in command_list))
        elif command in self.commands:
            print(self.commands[command].help)
        else:
            print(f"'{command}' is not a registered command. Run 'help' to list all commands.")
